---
title: "HotSpot_Animation"
author: "James Tsalah"
date: "8/23/2023"
output: html_document
---
# Load Packages & Data
```{r}
library(sf)
library(ggplot2)
library(purrr)
library(viridis)
library(magick)
library(MASS)
```

```{r}
rm(list=ls())
pts = read.csv(here::here("data", "mappings.csv"))
pts <- pts[complete.cases(pts$Latitude), ]
pts <- pts[complete.cases(pts$ObsDate), ]
pts <- pts[pts$ObsDate != "", ]

# EDDMaps has inconsistent datums, so we must account for that when creating an sf object.
consistent_datum <- function(data) {
  # Split the data into NAD83 and WGS84 subsets based on the "Datum" column
  nad83_data <- data[data$Datum == "NAD83", ]
  wgs84_data <- data[data$Datum == "WGS84", ]
  
  # Convert subsets to sf objects
  nad83_sf <- st_as_sf(nad83_data, coords = c("Longitude", "Latitude"), crs = 4269, remove = FALSE)
  wgs84_sf <- st_as_sf(wgs84_data, coords = c("Longitude", "Latitude"), crs = 4326, remove = FALSE)
  
  # Reproject the NAD83 subset to WGS84
  nad83_to_wgs84 <- st_transform(nad83_sf, crs = 4326)
  
  # Combine the WGS84 and reprojected NAD83 sf objects
  combined_sf <- rbind(wgs84_sf, nad83_to_wgs84)
  
  return(combined_sf)
}
pts_sf <- consistent_datum(pts)
class(pts_sf) # Must be SF Object
```

Example code for if you want to use the contiguous US from a census shapefile (https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html).
```{r}
contig_us = st_read(here::here('data', 'cb_2018_us_state_5m', 'cb_2018_us_state_5m.shp'))
contig_us = contig_us[!(contig_us$STUSPS %in% c("AK","HI", "GU", "VI", "PR", "MP", "AS")),]
contig_us = st_union(contig_us)
contig_us = st_transform(contig_us, st_crs(pts_sf))
contig_us <- st_cast(contig_us, "POLYGON")
class(contig_us)
```

# Animate Simple
Animate points over time without hotspot analysis.
```{r}
animate_spatial_data_simple <- function(pts_sf, polygon_sf) {
  
  # Compute the bounding box of all points or the provided polygon
  full_extent <- st_bbox(rbind(polygon_sf, pts_sf))

  # List of years
  unique_years <- sort(unique(pts_sf$Year))

  # Generate plots for each year and save them as individual image files
  plot_files <- map_chr(unique_years, function(year) {
    
    # Subset data for cumulative points up to the year
    subset_data <- pts_sf[pts_sf$Year <= year,]
    
    p <- ggplot() +
      # Add the provided polygon as a base layer
      geom_sf(data = polygon_sf, fill = "lightgray") +
      # Add the points
      geom_sf(data = subset_data, size = 0.1) +
      labs(title = paste("Up to Year:", year)) +
      theme_linedraw()
    
    filename <- paste0("plot_", year, ".png")
    ggsave(filename, p, width = 8, height = 4.5)
    return(filename)
  })

  # Load saved plots and create a gif
  plots <- map(plot_files, image_read)
  animation <- image_join(plots)
  animation <- image_animate(animation, fps=1)  # Adjust fps (frames per second) as desired
  image_write(animation, "animated_map.gif")
  
  return("animated_map.gif")
}

# To run the function, you can keep the data preprocessing part:
class(pts_sf)
# Format Date to notate as Year
pts_sf$Year <- ifelse(as.numeric(substr(pts_sf$ObsDate, 7, 8)) <= 23, # Edit Current Year
                      as.numeric(paste0("20", substr(pts_sf$ObsDate, 7, 8))),
                      as.numeric(paste0("19", substr(pts_sf$ObsDate, 7, 8))))

# Minimum unique data points required for kde2d to work
min_points <- 10

# Filter out rows from pts_sf based on the minimum number of unique data points for each year
pts_sf <- pts_sf[pts_sf$Year %in% unique(pts_sf$Year)[sapply(unique(pts_sf$Year), 
             function(yr) nrow(unique(pts_sf[pts_sf$Year == yr, c("geometry")])) >= min_points)], ]

animate_spatial_data_simple(pts_sf, contig_us)
```

# Animate W/ HotSpot Analysis
Animate points over time with hotspot analysis.
```{r}
animate_spatial_data_hotspot <- function(pts_sf, polygon_sf) {
  
  density_to_sf <- function(sf_object, xlim, ylim, n = 100) {
    
    # Ensure that the object is an sf object
    if (!inherits(sf_object, "sf")) stop("The input should be an sf object.")
  
    # Extract coordinates
    coords <- st_coordinates(sf_object)
    data <- data.frame(x = coords[, "X"], y = coords[, "Y"])
    
    # Exclude non-finite values
    data <- subset(data, is.finite(x) & is.finite(y))
    
    # Compute the density with fixed limits
    dens <- kde2d(data$x, data$y, n = n, lims = c(xlim, ylim))
    
    # Convert the density to contour lines
    contour_list <- contourLines(dens$x, dens$y, dens$z)
    
    # Build an sf object with level data
    sf_list <- lapply(contour_list, function(line) {
      df <- data.frame(x = line$x, y = line$y, level = line$level)
      
      # Force-close the contour if it's not closed
      if (!identical(df[1, ], df[nrow(df), ])) {
        df <- rbind(df, df[1, ])
      }

      # Check for valid polygon with at least 4 unique points
      if (nrow(unique(df[,1:2])) < 4) return(NULL)
      
      geom <- st_sfc(st_polygon(list(as.matrix(df[, 1:2]))), crs = st_crs(sf_object))
      st_sf(level = line$level, geometry = geom)
    })
    
    # Filter out NULLs and combine all sf objects into one
    sf_out <- do.call(rbind, Filter(Negate(is.null), sf_list))
    
    return(sf_out)
  }

  # Compute the bounding box of all points or the provided polygon
  full_extent <- st_bbox(rbind(polygon_sf, pts_sf))

  # Add a padding (e.g., 0.05) to prevent clipping at the edges
  padding <- 0.05 * c(diff(full_extent[c(1, 3)]), diff(full_extent[c(2, 4)]))
  xlim <- c(full_extent[1] - padding[1], full_extent[3] + padding[1])
  ylim <- c(full_extent[2] - padding[2], full_extent[4] + padding[2])

  # Compute density for all data points to get the global range
  global_dens_sf <- density_to_sf(pts_sf, xlim, ylim)
  global_range <- c(0, max(global_dens_sf$level))

  # List of years
  unique_years <- sort(unique(pts_sf$Year))

  # Generate plots for each year and save them as individual image files
  plot_files <- map_chr(unique_years, function(year) {
    # Subset data for cumulative points
    subset_data <- pts_sf[pts_sf$Year <= year,]
    
    # Compute the density and convert it to an sf object with consistent xlim and ylim
    dens_sf <- density_to_sf(subset_data, xlim, ylim)
    
    p <- ggplot() +
      # Add the provided polygon as a base layer
      geom_sf(data = polygon_sf, fill = "lightgray") +
      # Add hotspot layer using the sf density polygons
      geom_sf(data = dens_sf, aes(fill = level)) +
      scale_fill_viridis_c(option = "H", limits = global_range, name = "Density", n.breaks = 10, direction = 1) + 
      # Add the points on top of the hotspot layer with smaller size
      geom_sf(data = subset_data, size = 0.1) +
      labs(title = paste("Up to Year:", year)) +
      theme_linedraw()
    
    filename <- paste0("plot_", year, ".png")
    ggsave(filename, p, width = 8, height = 4.5)
    return(filename)
  })

  # Load saved plots and create a gif
  plots <- map(plot_files, image_read)
  animation <- image_join(plots)
  animation <- image_animate(animation, fps=1)  # Adjust fps (frames per second) as desired
  image_write(animation, "animated_hotspot_map_with_bg.gif")
  
  return("animated_hotspot_map_with_bg.gif")
}

# Format Date to notate as Year
pts_sf$Year <- ifelse(as.numeric(substr(pts_sf$ObsDate, 7, 8)) <= 23, # Edit Current Year
                      as.numeric(paste0("20", substr(pts_sf$ObsDate, 7, 8))),
                      as.numeric(paste0("19", substr(pts_sf$ObsDate, 7, 8))))

# Minimum unique data points required for kde2d to work
min_points <- 10

# Filter out rows from pts_sf based on the minimum number of unique data points for each year
pts_sf <- pts_sf[pts_sf$Year %in% unique(pts_sf$Year)[sapply(unique(pts_sf$Year), 
             function(yr) nrow(unique(pts_sf[pts_sf$Year == yr, c("geometry")])) >= min_points)], ]

animate_spatial_data_hotspot(pts_sf, contig_us)
```






